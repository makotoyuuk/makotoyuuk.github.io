[ { "title": "翻页进度条", "url": "/posts/%E7%BF%BB%E9%A1%B5%E8%BF%9B%E5%BA%A6%E6%9D%A1/", "categories": "技术总结", "tags": "技术", "date": "2022-06-04 12:52:00 +0000", "snippet": "项目概述：网页的页面翻页页数的统计展示效果HTML部分遵循包含式命名（层级关系）css部分 :root // 和HTML选择器一样 定义全局 align-item // 对齐方式 中心对齐常用 align-item:center justify-content // 定义了浏览器之间，如何分配顺着弹性容器主轴 (或者网格行轴) 的元素之间及其周围的空间。 overflow // 设定页面内容过多时的显示方式（滚轮等） ::before // 在每个元素前插入某样样式 （::after是向后 两个冒号是最新的 一个只支持IE8） content // 一般放在before和after后 用来插入内容 transform // 允许你旋转，缩放，倾斜或平移给定元素。 z-index // 设置元素的重叠顺序（一般设置为-1）script 部分利用了forEach的遍历函数 获取元素 设置计数器（currentActiive） 判断前进和后退按钮是否在原点或是在终点 插入更新函数和遍历函数（计算已经到达过的“原点”）添加运动变量 处理运动变量 progress.style.width = (actives.length-1)/(circles.length-1)*100+&#39;%&#39;" }, { "title": "JS笔记", "url": "/posts/js%E8%AF%AD%E6%B3%95/", "categories": "", "tags": "基础工具", "date": "2022-04-25 17:31:57 +0000", "snippet": "JS笔记浏览器执行JS：渲染引擎 JS引擎浏览器主要是以JS引擎来执行JS代码JS组成:ECMAScript(js语法): Javascript(网景公司）&amp;amp;Jscript（微软公司）原欧洲计算机制造商协会DOM(页面文档对象模型) 是W3C组织推荐的处理可扩展标记语言的标准编程接口 可以对页面上的各种元素进行操作BOM(浏览器对象模型) 对浏览器窗口进行操作三种书写位置：行内式 内嵌式 外部JS样式##注释：单行注释 ctrl +/多行注释 ctrl shift /##输入与输出：浏览器弹出警示框alert(&#39;&#39;)浏览器控制台打印输出信息 控制台输出(开发人员查看 F12)console.log(&#39;&#39;) 浏览器弹出输入框用户可输入（接收用户输入的数据）prompt(&#39;&#39;)变量装东西的盒子 用于存放数据的容器 通过变量获取数据 更改数据是程序在内存中申请的一块用来存放数据的空间变量的使用 声明 var age; (variable) 通过变量来访问数据 赋值 age=10 输出结果 console.log(age) 变量的初始化 var age =18 声明一个变量并赋值 存储变量 var age = prompt(‘’) 输出 alert(‘’)变量的语法扩展1.更新变量 一个变量被重新赋值后 它原有的值会被覆盖 变量值将以最后一次赋的值为准var age = 18;age = 82; //最后的结果是82因为18被覆盖掉了2.声明多个变量 只需一个 var 之间用逗号隔开var age=10, name=&#39;zs&#39;, sex =2;3.声明变量特殊情况var age; console.log(age); //只声明不赋值undefined;console.log(age); //不声明 不赋值直接使用 报错age =10; console.log(age) //不声明只赋值 10变量命名规范 由字母（A-Z a-z)、数字(0-9)、下划线(_)、美元符号($) 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法，首字母小写，后面单词的首字母需要大写数据类型js是动态语言: 不同数据占用的空间不同 为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型变量的数据类型 javascript的数据类型是只有程序在运行过程中根据等号右边的值来确定的var age = 10;//这是一个数字型var areyouok =&#39;是的&#39;；//这是一个字符串 js拥有动态类型 同时也意味着相同的变量可用作不同的类型var x = 6; //x为数字var x = &quot;bill&quot; //x为字符串js简单数据类型 Number 数字型 包含整型值和浮点型值 默认值为0 数字型进制 在JS中八进制前面加0，十六进制前面加0x 数字型范围最大值 Number.MAX_VALUE最小值 Number.MIN_VALUE 数字型三个特殊值alert(Infinity); //Infinity 无穷大alert(-Infinty); //-Infinty 无穷小alert(NaN); //NaN 代表一个非数值isNaN() 用来判断一个变量是否为非数值的类型 返回ture false Boolean 布尔值类型 ture false 默认值为falseture参与加法运算当作1 false当作0 String 字符串类型 都带有引号 默认为”“字符串型 可以是引号中的任意文本 加双引号或者单引号var strMsg= &quot;我爱天安门~&quot;; //使用双引号表示字符串var strMsg2= &#39;我爱吃猪蹄~&#39;; //使用单引号表示字符串常见错误var strMsg3= 我爱大肘子; // 报错，没使用引号 会被认为是js代码 一般推荐使用单引号 可以用单引号嵌套双引号 或者双引号嵌套单引号（外双内单，外单内双）var strMsg = &#39;我是“高富帅”程序员&#39;; //可以用&#39;&#39;包含&quot;&quot;var strMsg2 = “我是‘高富帅’程序员”; //也可以用&quot;&quot;包含&#39;&#39;常见错误var badQuotes = &#39;what on earth?&quot;; //报错，不能单双引号搭配字符串转义符 转义符都是\\开头的\\n 换行符 newline\\ 斜杠\\ &#39; ‘单引号&quot; “双引号\\t tab缩进\\b 空格blank字符串长度 通过字符串的length属性可以获取整个字符串的长度字符串的拼接”+” 字符串+任何类型=拼接之后的新字符串// 字符串&quot;相加&quot;alert(&#39;hello&#39;+&#39;&#39;&#39;world&#39;); //hello world// 数值字符串&quot;相加&quot;alert(&#39;100&#39;+&#39;100&#39;); //100100// 数值字符串+数值alert(&#39;11&#39;+12); //1112 口诀：数值相加，字符相连字符串拼接加强 变量不要写到字符串里面，是通过和字符串相连的方式实现的 Undefined 声明了变量但没有给值 默认为undefined未定义数据类型 undefined与数字相加=NaNNull 声明了变量但为空值 默认为Null（js用户交互：1提示用户输入 2程序内部处理 3输出结果）检测数据类型:console.log(typrof var);(prompt 取过来的是字符型的)字面量 是源代码中一个固定值的表示法 字面量就是表示如何表达这个值 数字字面量：8，9，10字符串字面量：’黑马程序员’,”大前端”布尔字面量：true false数据类型转换 把一种数据类型的变量转换成另外一种数据类型常用的3种转换//转换为字符串:toString()； var num=1;alert(num.toString());//转换为数字型:String()强制转换 var num=1;alert(String());//加号拼接字符串 var num=1; alert(num + &quot;字符串&quot;)；//（第三种方法称之为隐式转换）//转换为数字型：parseInt(string)函数: parseInt(&#39;79&#39;); 会去掉单位 取整parseFloat(string) 函数 parseFloat(&#39;78.21&#39;); 得到小数Number()强制转换函数 Number(&#39;12&#39;)//js隐式转换(- * /) &#39;12&#39;-0; //利用了算数运算//转换为布尔型Boolean()函数 Boolean(&#39;ture&#39;);//代表空、否定的值会被转换为false 其他值都会被转换为ture 解释型语言（js） 编译型语言（java)编译器翻译的方式有两种 一个是编译 另一个是解释 两者的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译 生成中间代码文件 解释器是在运行时进行及时解释 并立即执行（当编译器以解释方式运行时，也称之为解释器）标识符： 值开发人员为变量、属性、函数、参数取的名字标识符不能时关键字或保留字关键字： JS已经使用了的字 不能用来命名变量保留字： 现在不是关键字 但未来可能成为关键字 不能用运算符 operator 算术运算符（+ - * / %）都要敲空格 浮点数算术运算精度问题 不要用浮点数来直接比较大小 表达式和返回值 数字和运算符和变量 结果为返回值 右边计算完把返回值给左边 递增和递减运算符 ++ – 必须和变量一起使用 前置递增 ++age//age=age+1 先自加1后返回值 后置递增 age++// 先返回原值 后自加1 开发中后置用的比较多 单独占一行 比较运算符 逻辑运算符 短路运算（逻辑中断）：当有多个表达式（值）可以确定结果时，就不再继续运算右边的表达式的值 逻辑与短路运算：语法：表达式1&amp;amp;&amp;amp;表达式2 如果表达式1为真则返回表达式2 若为假则返回表达式1 逻辑或短路运算：若1为真则返回1若1为假则返回2 赋值运算符(= += -= *= %= /=)运算符优先级： 小括号&amp;gt;一元运算符&amp;gt;算术运算符&amp;gt;关系运算符&amp;gt;相等运算符&amp;gt;逻辑运算符&amp;gt;赋值运算符&amp;gt;逗号运算符 一元运算符里面的逻辑非优先级很高 逻辑与比逻辑或优先级高流程分支 流程控制：顺序、分支、循环分支结构：if语句：if(条件表达式){执行语句};if else if语句（多分支语句）//利用多个条件来选择不同的语句执行 得到不同的结果 多选1的过程语法规范：if (条件表达式){语句1}else if (表达式2){语句2}eles{最后的语句}三元表达式 有三元运算符组成的式子语法结构：条件表达式 ？ 表达式1 ： 表达式2switch语句：语法结构：switch(表达式){case value1:执行语句1;break;...default: 执行最后的语句;}//注意事项：//1、在开发中，表达式我们经常写成变量//2、我们num的值和case里面的值和匹配的时候式全等才行循环结构： 循环的目的：可以重复执行某些代码for循环（循环体 终止条件）//通常跟计数有关系for(初始化变量;条件表达式;操作表达式){循环体} 初始化变量：用var声明的一个普通变量 用于作为计数器使用条件表达式：用来决定每一次循环是否继续执行 就是终止的条件操作表达式：每次循环最后执行的代码 经常用于我们计数器变量进行更新（递增或递减） 断点调试 观察程序的运行过程 sources (step into next function call) watch 循环重复不相同的代码 因为有计数器的存在 每次i的变换循环值都会变化双重for循环（循环嵌套）语法结构：for (外层的初始化变量；外层的条件表达式；外层的操作表达式){for (里层的初始化变量；里层的条件表达式；外层的操作表达式){ 执行语句}}//外层循环循环一次 里面的循环执行全部while循环语法规则：while （条件表达式）{循环体}//会出现死循环do…while循环语法：do{循环体}while(条件表达式)//先循环一次 条件满足则继续执行关键字：continue //跳出本次循环 继续下一次循环break //循环结束 while 和 do while 可以做更复杂的判断条件比for更灵活 实际工作中更常用for 更简洁直观数组: 一组数据的集合 每个数据称为元素 可存放任意类型元素 数据一定要用逗号隔开创建数组 1、利用new创建 var arr = new Array ();2、利用数组字面量创建 var arr = []; 数组的初始化访问数组元素 索引（下标 从0开始）console.log(arr[2]); 遍历数组（全部取出） 索引值在递增 利用循环 数组的长度 数组名.length (不是元素个数)数组新增元素 通过修改length的长度 修改长度：多一个为空 少一个为undefinedlength属性式可读写的 修改索引号 （就是替换） 不能直接给数组名赋值否则数据消失 数组排序（冒泡排序）: 把一些数据按照一定的顺序进行排序显示 1.一共要交换的趟数（外层for循环）arr.length-12.每一趟交换次数（里层for循环）arr.length-i-13.交换2个变量即可 函数: 封装了一段可以被重复执行调用的代码块 目的：大量代码重复使用 使用：1、声明函数 2、调用函数 函数名（） 函数不调用自己不执行 函数的参数： 形参 实参function (形参1，形参2...){} 函数名(实参1，实参2...); 形参式接收实参的 形参类似于一个变量 函数参数可有可无 个数不限 形参和实参的匹配问题 1.形参与实参的个数一致 则正常输出2.若实参个数&amp;gt;形参个数 取形参个数3.若实参个数&amp;lt;形参个数 NaN (形参默认undifend)函数的返回值 return 语句：function 函数名(){return 需要返回的结果;} 1、函数只是实现某种功能 最终结果需要返回给函数的调用者2、只要遇到return 就把后面的结果返回值给函数调用者 函数名()=return 后面的结果在实际开发时 常用一个变量来接收函数返回结果更简洁 return 终止函数: return后面的代码不会去执行return 只能返回一个值 (返回的结果是最后一个值) 也可返回数组没有return 则返回undefinedbreak: //结束当前循环 continue://跳出循环 继续执行下次的循环return://可退出循环 也能返回return 语句中的值 同时还可以结束当前函数的代码argument 的使用： 当不确定有多少个参数传递的时候 用argument来获取 他实际上是当前函数的一个内置对象所有函数都有 argument对象中存储了传递的所有实参使用：console.log (argument); argument 展示形式为伪数组 有length属性 按索引方式储存数据 不具有数组push pop等 （可遍历） 函数的两种声明方式：1、利用函数关键字自定义函数（命名函数）fuction fn(){}2、函数表达式var 变量名 = function () {};var 变量名 = function () { console.log(“我是函数表达式和”)；}fun ();(1) fun是变量名 不是函数名(2) 函数表达式声明方式跟声明变量差不多js作用域 1、就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突2、js的作用域：全局作用域 局部作用域全局作用域：整个script 标签 或者是一个单独的Js文件局部作用域：（函数作用域）在函数内部 这个代码名字只在函数内部起效果变量作用域全局变量 在全局作用域下的变量注意如果在函数内部没有声明直接赋值的变量也是全局变量局部变量 在局部作用域下的变量 只能在函数内部使用注意 函数的形参也可以看做是局部变量从执行效率来看全局变量和局部变量（1）全局变量只有浏览器关闭的时候才会销毁 比较占内存（2）局部变量 当我们程序执行完毕就会销毁 比较节约内存资源js中没有块级作用域（在es6才有）{} if{} for{}作用域链 内部函数访问外部函数的变量 采取的是链式查找的方式来取哪个值 采用就近原则变量提升：把所有的变量声明提升到当前的作用域最前面 不提升赋值操作函数提升：把所有函数声明提升到当前作用域的最前面 不调用预解析 javascript解析器运行的过程 预解析 js引擎回吧js里所有var和function 提升到当前作用域的最前面分为变量预解析（变量提升）函数预解析（函数提升） 代码执行 按照代码书写的顺序从上往下执行对象：是一组无序的相关属性和方法的集合 所有事物皆有对象包括：属性：事物的特征 对象中用属性来表示（名词）方法：事物的行为 对象中用方法来表示（动词）为什么需要对象 对象表达结构更清晰 更强大创建对象的三种方式：1、利用字面量花括号{}包含了表达这个具体事物（对象）的属性和方法1、里面的属性或方法我们采取键值对的形式2、多个属性或者方法中间用逗号隔开3、方法冒号后面跟的是一个匿名函数使用对象：1、调用对象的属性 采取对象名.属性名2、还可以对象名[‘属性名’]2、用new object要用分号3、构造函数变量、函数、属性方法总结变量与属性1、相同点 都是用来保存数据的2、不同点 变量：单独声明并赋值 使用直接写变量名（单独存在）属性：在对象中不必声明 必须是（对象.属性名）函数与方法1、相同点：都是实现某种功能2、不同点：函数单独存在而方法必须在对象中使用内置对象：指JS自带的一些对象 提供一些常用的或是最基本而必要的功能属性和方法（帮助快速开发）（Math Date Array String 等）Math对象不是一抖虚构函数 不用new来调用 而是直接使用里面的属性和方法即可1、绝对值 Math.abs() 有隐式转换console.log(Math.abs(num));2、取整方法 Math.floor() 向下取整 往小了取console.log(Math.floor(num));Math.ceil() 向上取整 往大了取console.log(Math.ceil(num));Math.round() 四舍五入 5特殊，往大了取console.log(Math.round(num));随机数方法 random()1、返回一个随机的小数2、函数里不跟参数3、得到两个数之间的随机整数 并且包含2个整数Math.floor(Math.random() *(max-min+1)) + min;日期格式化getFullyear() 获得当年getMouth() 获得当月（0-11） date.getMouth()+1getDate() 获得当天日期 getDay() 获得星期几（周日0点到周六6）getHours() 获得当前小时getMinutes() 获得当前分钟getSecond() 获得当前秒日期对象：处理日期和时间 是一个构造函数 必须使用new来调用创建日期对象1、使用Date var date = new Date(); 如果没有参数 返回当前系统的时间2、参数常用的方法数字型 2019，10，01字符串型 ‘2019-10-01 8：8：8’数字型输出结果会比实际的大1数组对象 创建方式：1、字面量方式2、new Array()检测是否为数组：1、instanceof 运算符 2、Array.isArray(参数) 新增添加删除数组元素方法1、push() 在数组末尾添加一个或多个元素参数直接写数组元素返回新数组的长度原数组也会变2、unshift() 在数组开头添加一个或多个元素参数直接写数组元素返回新数组的长度原数组也会变3、pop() 删除数组最后一个元素只能一次删一个没有参数返回删除的元素原数组会变4、shift() 可删除第一个数组元素只能一次删一个没有参数返回删除的元素原数组会变（重点案例）数组去重 要用到indexOf()indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。数组转换为字符串1、toString()2、join(分隔符)字符串对象基本包装类型：把简单数据类型包装为复杂数据类型(1)生产临时变量 把简单数据包装为复杂型(2)赋值给声明的字符变量(3)销毁临时变量var temp = new String(&#39;andy&#39;);str = temp;temp = null;不要大量拼接字符串 会大量占用内存字符串的不可变：指的是里面的的值不可变 虽然可以（看上去）改变内容 但其实地址变了 在内存中开辟了一个内存空间根据字符返回位置1、str.indexOf(‘要查找的字符’.[起始的位置]);str.lastindexOf(‘’.[]);根据位置返回字符（重点）1、charAt(index) （输入要查找字符的索引号 也可以用for循环来遍历整个字符）2、charCodeAt(index) （获得指定字符的AscII码） 目的判断用户按下了哪个键3、str[index] H5新增的字符串的操作方法（重点）concat(str1,str2,str3…) 拼接字符串substr(start,length) 提取字符从左到字符的总长度slice(start.end) 提取字符subString(start,end)简单数据类型string number boolean undefined Null(object空)引用类型（复杂数据类型）：在存储时变量中仅存地址通过new来用（系统对象 自定义对象）堆和栈栈：由操作系统自动分配释放存放函数的参数值（局部变量等） 存简单类型 存放的是值堆：有复杂类型 由程序员释放 否则被回收 javascript是没有堆和栈的 为的是方便理解API：应用程序编程接口是为程序员提供的一种工具 提高效率web API:可以控制浏览器功能（bom）和页面元素（dom）是针对浏览器做交互效果总结：1、API只管结果不管过程2、webAPI主要是针对浏览器做交互效果3、webAPI一般都有输入输出 很多都是方法（函数）4、用学内置对象的方法学DOM 文档对象模型（处理页面的接口可改变网页内容 结构和样式）DOM树（附图）文档»页面(document)元素»标签(element)节点»所有东西(node)DOM把以上内容都做为对象获取元素1、根据ID getElementById()2、根据标签名 getElementByTagName()（返回带有标签名的集合 以伪数组的形式存放 采取遍历的方式可依次打印里面的元素对象）(还可以根据获取父元素内部所有指定标签名的子元素 伪数组不可作为父元素)父元素必须是单个对象（必须指明是哪一个元素对象）但不包括父元素自己因得到的是一个对象的集合 要操作里面元素需要遍历得到元素对象是动态的3、根据类名 getElementByClassName()(括号里都是字符串 要写在标签的下面 地址要准确 返回的是一个元素对象)4、document.queryselector(‘选择器’)返回指定选择器的第一个元素对象（需要加符号）5、获得特别标签body:document.bodyhtml:document.documentElement操作元素1、改变元素内容2、常用元素的属性操作innerText innerHtmlsrc hrefid alt title表单元素的属性操作利用dom：type value checked selected disabled表单里面的值 文字内容是通过value来修改的禁用表单 disabled=turethis 指向的是事件函数的调用者样式属性操作1、element.style 行内样式操作2、element.className 类名样式操作注意js里面的样式采取驼峰命名法js修改style样式操作 产生的是行内样式 css权重比较高this.className =’change’ change写在style里 然后在js中加上className 在样式比较多的时候使用 可以更改更多的样式className会直接更改元素的类名 会覆盖原先的类名 (多类名的方法 见案例)操作元素是DOM核心内容树状图见手写笔记节点层级子节点parentNode.children(非标准)是一个只读属性 返回所有的子元素节点 它只返回子元素节点 其余节点不返回虽然是一个非标准 但是得到了各个浏览器的支持在实际开发常用parentNode.firstChild返回第一个子节点 找不到则返回null 也是包含所有的节点parentNode.lastChild返回最后一个子元素节点 找不到就返回null（注意：这两种方法有兼容器问题 IE9以上才支持)firstElementChild 返回第一个子元素节点(兼容IE9)实际开发的写法 既没有兼容性的问题又返回第一个子元素parentNode.children.length-1)兄弟节点nextSibling 下一个兄弟节点 找不到返回null 包含所有节点previousSibling 返回当前元素上一个兄弟节点 找不到就返回null 包含所有的节点创建节点元素节点 document.createElement(‘tagName’)创建由tagName指定的HTML元素 原先不存在 是根据我们的需求动态生成的 也称为动态创建元素节点添加节点node.appendChild(child) node父级 child是子级 将一个节点添加到指定父节点列表末尾 类似数组中的pushnode.insertBefore(child,指定元素) 将一个节点添加到父节点的指定子节点前面页面想添加一个新的元素1、创建元素2、添加元素删除节点node.removeChild(child) 从DOM中删除一个子节点 返回删除的节点复制节点node.cloneNode() 返回该方法的节点的一个副本 括号里为空或者里面是false 浅拷贝 只复制标签不复制里面的内容若括号里为true 深拷贝 复制标签复制里面的内容三种动态创建元素方式1、document.write()直接将内容写入页面的内容流 但文档流执行完毕后 则它会导致页面全重绘2、element.innerHTML 是将内容写入某个DOM节点 不会导致页面重绘 创建多个元素效率更高（不要拼接字符串 采取数组的形式拼接）3、document.createElement() 创建多个元素效率稍低 但结构清晰复习 讲出DOM的重点核心事件操作高级注册方式（两种）1、传统方式（唯一性 后面的会覆盖前面的）2、方法监听注册方式 （W3C标准 IE9之前不支持）addEventListener() 可用attachEvent()代替同一个元素同一个事件可以注册多个选择器（事件处理程序） 按注册顺序依次执行eventTarget.adEventListener(type.listener[,useCapture])eventTarget 目标对象type 事件类型 不带on必须加引号listener 事件处理函数useCapture 可选函数 是布尔值 默认为 falseattachEvent(事件监听方式)eventTarget.attachEvent(eventNameWithOn,callback)eventNameWithOn 事件类型字符串（带on)callback 事件处理函数 触发时回调函数被调用将指定的监听器注册到eventTarget(目标函数)上 对象触发指定事件时 指定的回调函数就会被执行DOM事件流描述的市从也买你中接收事件的顺序事件发生时会在元素节点之间按照特点的顺序传播 传播过程为事件流分三个阶段1、捕获阶段2、当前目标阶段3、冒泡阶段注意：1、JS中只能执行捕获或冒泡其中一个阶段2、实际开发中很少用事件捕获3、有些事件是没有冒泡的 onblur onfocus onmouseenter onmouseleave4、事件冒泡有时会带来麻烦addEventlistener(type,listener[,useCapture]) 最后一个参数为true则在捕获阶段用事件 false则在冒泡阶段使用（或省略时）事件对象div.onclick=function(event){}1、事件对象 event写在监听器函数的小括号里 当形参2、事件对象只有有了事件才会存在 是系统自动创建 不需要传递参数3、事件对象是事件的一系列相关数据的集合 跟事件相关4、事件对象可以自己命名（event/evt/e）5、兼容性 e=e||window.event.常见属性和方法e.target //返回触发事件的元素 this返回绑定事件的对象e.srcElement //兼容性e.type //返回事件类型e.currentTarget //兼容性e.preventDefault() //阻止默认行为（事件）e.returnValue //低版本return flase //无兼容性问题但后续代码不执行阻止事件冒泡两种方式stopPropagation() //标准写法 在function里写e.cancelBubble() //兼容性事件委托（代理 jquery称委派）原理（要能口述出来）不是每个子节点单独设置事件监听器 而是事件监听器设置在其父节点上然后利用冒泡原理影响设置的每个子节点作用：只操作了一次DOM 提高了程序的性能常用的鼠标事件1、禁止鼠标右键菜单document.addEventListener(&#39;contextmenu&#39;, function(e) { e.preventDefault();})2、禁止鼠标选中 selectstartdocument.addEventListener(&#39;selectstart&#39;, function(e) { e.preventDefault();})鼠标事件对象（mouseEvent)e.clientX 返回鼠标相对于浏览器窗口可视区的x坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的y坐标e.pageX 返回鼠标相对于文档页面的X坐标 ie9支持e.pageY 返回鼠标相对于文档页面的y坐标 ie9支持e.screenX 返回鼠标相对于电脑屏幕的X坐标e.screenY 返回鼠标相对于电脑屏幕的y坐标千万不要忘记给left top加上px单位！！！常用的键盘事件1、onkeyup 某个键盘按键松开时触发2、onkeydown 某个键盘按键被按下时触发3、onkeypress 某个键盘按键被按下时触发 但是它不识别功能键三个事件的执行顺序 keydown keypress keyup键盘事件对象keycode 返回ASCII码值keyup keydown事件不区分字母大小写 keypress区分大小写可以利用keycode返回的ASCII码值来判断用户按下了哪个值BOM概述：浏览器对象模型 提供了浏览器窗口进行交互的对象核心对象是window 缺乏标准 兼容性差由一系列对象构成 每个对象提供很多方法与属性与DOM的区别DOM：文档对象模型 对象是文档document是顶级对象学习操作页面元素w3c标准BOM： 浏览器对象模型对象是浏览器window为顶级对象学习浏览器窗口交互的一些对象缺乏标准兼容性差构成：BOM&amp;gt;DOM 包含关系window documentlocationscreenhistorywindow js访问浏览器窗口的一个接口是全局对象 定义在全局作用域中的变量、函数都会变成window对象的属性和方法window下的一个特殊属性window.name(避免直接使用)window常见事件 窗口加载事件 window.onload=function(){} window.addEventListener(&#39;load&#39;, function(){}) 当文档完成加载后才执行 可将js代码写在上方 只能写一次 只以最后一个为主 第二种不影响 document.addEventListener(‘DOMContentLoaded’,function(){})仅当Dom加载完成（不包括样式表、图片、flash等 ie9以上 当图多的时候onliad速度慢调整页面窗口大小事件window.onload=function(){}window.addEventListener(‘resize’, function(){})只要窗口大小发生像素变化 常用于完成响应式布局window.innerwidth(当前屏幕宽度)定时器：setTimeout() setInterval()window.setTimeout(调用函数,[延迟的毫秒数])window、毫秒可省略 默认为0可以直接写函数 还可以写函数名不推荐使用’函数名()’定时器一定要取名！也称回调函数 callbacksetInterval()定时器window.setInterval(回调函数,[间隔的毫秒数])重复调用一个函数 每过一个时间 调用一次方式与setTimeout一致一定要取名！异步与同步1、js执行机制 单线程 同一时间只能做一件事后果：执行时间过长 页面渲染不连贯 加载阻塞2、为此提出异步和同步 利用多核CUP的能力异步：多个任务同时进行（多线程） 同步：一个任务完成后再执行下一个任务 执行顺序：任务排列顺序三种：普通事件（click resize等）资源加载（load error等）定时器（setlnterval settimeout等）添加到任务队列中（消息队列）执行机制：同步任务：（主线程执行栈）都在主线程执行，形成执行栈异步任务：通过回调函数实现1、限制性同步任务2、是否有异步任务 有则先放在任务队列中3、执行完成所有同步任务 再将异步任务放在最后一个同步任务后执行多异步任务主线程执行栈&amp;gt;异步进程处理&amp;gt;任务队列（执行完则空） event loop 反复确定异步location对象1、window中的一个属性 用于获取或设置窗体的URL 并由于解析URL（返回一个对象因此也称为location对象）URL:uniform resource locator 统一资源定位码互联网上标准资源地址一般语法protocol://host[:port]/path/[?query]#fraguenthttp://www.itcat.cn/index.html?name=andy&amp;amp;age=18#link组成：proticol host port path query fragmentlocation对象属性location.href 获取或设置整个URL*location.host 返回主机（域名）location.prot 返回端口号 如果没写返回 空字符串location.pathname 返回路径location.search 返回参数location.hash 返回片段#后面内容常见于链接锚点 *location常见方法location.assign() 相当于href 可跳转（重定向页面）location.replace() 替换页面 但不记录浏览历史 不可后退location.reload() 重新加载页面 相当于F5 若参数为true则强制刷新ctrl+F5navigator对象判断用户使用的是什么终端（useagent）history对象比较少用 OA系统会用back() 后退forword() 前进go(参数) 前进+后退-PC端网页特效1、offset获取元素距离带有定位父元素的位置获取元素自身的大小（宽度高度）注意：返回的数值都不带单位offset系列常用属性element.offsetParent 返回作为该元素带有定位的父级元素 若父级都没有定位元素则返回body返回带有定位的父亲 没有则返回bodyelement.parentNode 返回最近一级的父亲 不管有无定位element.offsetTop 返回元素相对带有定位父元素上方的偏移element.offsetLeft 返回元素相对带有定位父元素左边框的偏移以带有定位的父亲为准 如果没有父亲或者父亲没有定位 则以body为准element.offsetWidth 返回自身包括padding 边框 内容区的宽度 返回数值不带单位element.offsetHeight 返回自身包括padding 边框 内容区的噶都度 返回数值不带单位可以得到元素的大小 宽度和高度 是包含padding border width 写了一千行辣！！！offset与style的区别offset可以得到任意样式表中的样式值获得的数值是没有单位的offsetWidth包含padding border widthoffsetWidth等属性是只读属性 只能获取不能赋值想获取元素大小位置 offset比较合适style只能得到行内样式表中的样式值style.width获得的是带有单位的字符串style.width获得不包含padding border的值style.width 是可读写属性 可以获取也可以赋值想给元素更改值 用style改变元素可视区client系列client&amp;gt;客户端可以动态得到该元素的边框大小、元素大小等element.clientTop 返回元素上边框的大小element.clientLeft 返回元素左边框的大小element.clientWidth 返回自身包括padding 内容区的宽度 不含边框 返回数值不带单位element.clientHeight 返回自身包括padding 内容区的高度 不含边框 返回数值不带单位立即执行函数 不需要调用 立马能够自己执行的函数写法 也可以传递参数进来 (function(){})()或者 (function(){}())第二个小括号可以看作是调用函数多个立即执行函数 必须要分开立即执行函数最大的作用：独立创建了一个作用域 变量命名不会冲突元素滚动scroll可以动态得到该元素的大小、滚动距离等element.scrollTop 返回被卷去的上侧距离 返回数值不带单位element.scrollLeft 返回被卷去的左侧距离 返回数值不带单位 element.scrollWidth 返回自身的实际宽度 不含边框 返回数值不带单位element.scrollHeight 返回自身的实际高度 不含边框 返回数值不带单位是真正内容的大小 不同于client页面被卷去的头部onscroll 事件三大系列总结主要用法1、offset系列经常用于获得元素位置2、client经常用于获取元素大小3、scroll经常用于获取滚动距离4、注意页面滚动的距离通过window.pageXOffset获得mouseenter和mouseover的区别（面试重点）当鼠标移动到元素上时会触发mouseenter事件mouseover 鼠标经过自身盒子会触发 经过子盒子也会触发 mouseenter只会经过自身盒子才触发是因为mouseenter不会冒泡（mouseleave也是一样）---------------------------------------------------------------- 动画函数封装 动画实现原理：通过定时器setInterval()不断移动盒子位置 实现步骤： 1、获得盒子当前位置 2、让盒子在当前位置上加上1个移动距离 3、利用定时器不断重复这个移动距离 4、设置结束定时器条件 5、注意此元素需要添加定位 才能使用element.style.left动画函数的简单封装注意函数需要传递2个参数：动画对象和移动到的距离动画函数给不同元素记录不同定时器如果多个元素都使用这个动画函数 每次都要var声明定时器 可以给不同的元素使用不同的定时器（自己专门用自己的定时器）核心原理：利用js是一门动态语言 可以很方便的给当前对象添加属性不断点击按钮 会开启太多定时器解决方案:让元素只有一个定时器 先清除以前的定时器 只保留当前的一个定时器执行缓动效果原理缓动动画就是让元素运动速度有所变化 最常见的是让速度慢慢停下来思路：1、让盒子每次移动额距离慢慢变小 速度会慢慢落下来2、核心算法：（目标值-现在的位置）/10 作为每次的步长3、停止的条件时：让当前盒子位置等于目标位置就停止定时器dpr物理像素比 设置body的字体大小 网页端为1 移动端为2reset rem unit on page resize 当页面尺寸大小发生变化时 要重新设置下rem 的大小pageshow 是重新加载页面三种情况都会刷新页面都会触发load事件1、a标签的超链接2、F5或者刷新按钮3、前进后退火狐中有个“往返缓存” 不仅保存着页面数据 还保存了DOM和Javascript的状态 实际上是将整个页面都保存在了内存里 此时后退按钮不能刷新页面此时必须要用pageshow事件来触发注意这个事件给window添加" }, { "title": "收缩相册", "url": "/posts/%E6%94%B6%E7%BC%A9%E7%9B%B8%E5%86%8C/", "categories": "技术总结", "tags": "技术", "date": "2022-03-26 02:34:00 +0000", "snippet": "HTML部分 &amp;lt;div class=&quot;panel active&quot; style=&quot;background-image: url(&#39;img/1.jpg&#39;)&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt; &amp;lt;!-- 在title前 --&amp;gt; &amp;amp;&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 在&amp;lt;/body&amp;gt;前 --&amp;gt;css部分```box-sizing: border-box;定义了 user agent 应该如何计算一个元素的总宽度和总高度不会再计算盒子的padding和border的宽度``````display:flex;能够扩展和收缩 flex 容器内的元素，以最大限度地填充可用空间```弹性布局属性详解 vw单位 width: 110vw; 在css中，vw是一个长度单位，一个视口单位，是指相对于视口的宽度；视口会被均分为100单位的vw，则1vw等于视口宽度的1%，比如浏览器的宽度为1920px，则“1vw=1920px/100=19.2px”。说明 border-radius: 50px; /* 圆形框 */ cursor: pointer; /* 关键字值 */ flex: 0.5; /* 图像的可变化大小 */ opacity: 0; /* 不透明度 */ 动画实现 transition: opacity 0.3s ease-in 0.4s; /* 变化 */js部分关键字的说明：现在主要都是使用const声明方式 forEach函数 panels.forEach(panel =&amp;gt; { panel.addEventListener(&#39;click&#39;, () =&amp;gt; { removeActiveClasses() panel.classList.add(&#39;active&#39;) }) }) &amp;lt;!-- 确定用户点击的对象是谁 将active类转递给它 再由css来控制它 主要是同通过添加active这个类来达到控制css对象的变化 --&amp;gt; function removeActiveClasses() { panels.forEach(panel =&amp;gt; { panel.classList.remove(&#39;active&#39;) }) } //这里是取消所有未点击的panel的active属性" }, { "title": "如何阅读计算机科学类的书", "url": "/posts/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%B1%BB%E7%9A%84%E4%B9%A6/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "作为一个研发工程师，无论你是否喜爱阅读，相信你都一定读过不少关于计算机技术的书籍。这其中不乏《21天学会JAVA》这样的语言入门书籍，也有《算法导论》这样的专题书籍，也有《人月神话》这样关于软件管理学的实用性的书籍。也许你已经读过他们中的大部分，也许你现在还在不断地购入新的书籍来补充你的知识库。但请稍等一下，你是否思考过这样的问题，面对大量的计算机科学书籍，你是否都真正读懂了它们呢？有多少本书，当你将他放在书架上之后，就再也没有重新打开过？有多少知识是真正被存储在你的大脑中，并随时可以提供调用？拿到一本书后，高效阅读的正确姿势的什么？如果你有以上的疑惑，那么接下来，我们将一起探讨一个问题，如何阅读一本计算机科学类书籍。阅读的四种层次首先，我们先要学会如何阅读。你可能会觉得不可思议，我已经接受过高等教育，怎么可能还不会阅读。然而可悲的是，现代教育体系中，恰恰忽略了对阅读能力的训练。我们在初中之后，阅读水平就几乎没有机会再得到提升。总体来说，阅读分为四种层次，分别是： 基础阅读 检视阅读 分析阅读 主题阅读这其中的概念来源于莫提默·J·艾德勒和查尔斯·范多伦的著作《如何阅读一本书（How To Read A Book）》，这里我必须对其中的概念做简单的总结，以便在后续的篇幅中，我们能统一对阅读名词的理解。基础阅读当我们完成中学学业后，我们中的绝大部分人，都已经掌握了基础阅读的能力。在这个层次中，我们关心的是，书里的每句话是什么意思。这是一个最基础的层次。检视阅读检视阅读，我们也可以称之为快速阅读。快速浏览全书，了解书的主题，架构全书，提出核心问题。这并不是很新鲜的概念，但很多人可能并没有思考过，为什么要做检视阅读。检视阅读作用是为了帮助我们筛选这本书是否值得阅读，同时为接下来的分析阅读打下基础。在这个层次中，我们关心的是，这本书在讲什么。分析阅读分析阅读是一个更为高级的阅读层次，目标让我们能充分理解本书，与作者对话。其中包含了多个阶段，这里不再详述，有兴趣的同学可以研读原著。主题阅读当我们跨越过分析阅读后，这本书已经被我们掌握。此时，我们会就相同的主题，阅读不同的书籍，找出其中关联与矛盾，倾听不同的作者的不同声音，从而对某个主题产生更加深刻的认识。这个阶段，我们关注的不再是某一本书，而是一个具体的问题。计算机科学书籍的特征原著中针对不同类型的书籍，给予了不同的阅读建议。但由于所著时间很早，就计算机科学类图书的阅读建议，在书中并没有专门设计章节阐述。根据我的阅读经历，深感计算机科学类书籍，较其他类型图书有着其独特性：单本书籍的信息量大相较其他学科，绝大多数计算机科学类书籍并不是以得出结论并且论证结论为核心，而偏重于阐述方法和解释原理。有很多计算机书籍旨在剖析某个系统。这里的系统不仅仅指代诸如操作系统这样的实体系统，还包括一门语言或者一套管理方法论这样的理论系统。而系统通常是由多个部分组成的综合体，这其中势必包含不同组成部分的不同细节，信息量之大可见一斑。注重实践计算机科学是一门实用性的学科。这里的实用性可以理解为，计算机科学诞生的目的就是为了解决实际问题。因此，几乎所有的计算机科学书籍，都是以指导实践为目标而作。更新速度快计算机科学的更迭速度可以准确地被描述为日新月异。有些技术很快地火爆起来，又很快地消亡，所以有些书也就跟着很快地淹没在时代的进程中。分类细致但同质度高计算机科学对自己有着过分清晰的划分，不同的技术之间往往边界清晰。我们很少见操作系统和数据库系统在同一本书中论述，也不常见集不同语言之成的大作。由于领域划分细致，相同领域的书籍，多数时候往往论述的是同样的主题。阅读计算机科学书籍的误区绝大多数读者的错误意识在于把所有的书籍都认为是层层推进的论述过程。这样的阅读经验一旦沿用在计算机科学类书籍中，就会感觉举步维艰。前文说过，大多数的计算机书籍都是在剖析系统，一个系统又是由许多相互关联的部分组成。解读这类书籍，如同拆解一个机械，我们在拆解的过程，常常会犯下这些错误。通读全书在你的头脑中没有对全书的结构有整体了解的情况下，从头至尾通读全书，意味着试图从细节窥视一个系统的全貌。这是一种低效的读书方式。当读到中落时，你会因为没有全局概念，而迷失在各种细节中，以至于完全失去了阅读的方向和目标。跳过序言序言往往是很多人忽略的内容，似乎序言只是重复了正文的内容。而正因为如此，序言以简短精炼的语言，为你分解了整本书的架构，帮助你把握系统的整体。这项工作本来应该是读者在阅读全书之前的必备工作，绝大多数的作者都已经帮你完成了，而你需要做的仅仅是认真的阅读它。脱离实践前文说过，计算机科学类书籍重视实践，脱离了实践，往往就不能完全理解书中所述的理论和方法，过目就忘，纸上谈兵。忽视基础封装在计算机的世界中是一个非常重要的概念。计算机的发展史，总的来说就是一部封装史：将底层不断包装，提供简单的调用方式，由此不断的扩展计算机的边界和能力。新的技术层出不穷，而他们的很多所依赖的环境和系统，从设计之初就没有发生过质的变化。有时，在追逐新的技术之前，深入了解他们所在的系统；在学习新的算法之前，掌握好其基础的数学原理。只有牢固的基础才能支撑足够结实的上层建筑。阅读计算机科学书籍的建议当了解阅读误区后，你们是不是已经发现阅读这类书籍的核心原理呢？那就是将整本书当做一个系统，从整体到局部，层层递进，逐步剖析。根据这个核心原理，我总结了一些好的实践方式。检视阅读当你拿到一本计算机科学书籍，第一步就应该快速浏览序言和目录，然后用检视阅读的方式整理出整本书的大纲。这样，你对这本书是介绍理论还是关注实践，所属什么分类，哪些问题是本书将会讨论，而哪些问题是不被详细讨论的，这些信息你都会有整体上的认知。这时，你就可以很轻松地判断，这本书值不值的阅读，哪些内容是你已经熟知的，哪些内容是你关注的重点，这样做阅读的效率将会大大的提高。如果从来没有使用过这种阅读方式，开始实践时，会受到一定的心理上的阻力。可能你对某个专有名词完全没有概念，以至于整章的内容都模棱两可。这时，你应该坚持继续阅读，对不甚理解的内容，先记住有这样的概念。绝大多数的时候，经过检视阅读后，过程中的问题都会有所释怀，剩下依然没有明白的内容，视其重要性，再决定是否对其进行分析阅读。提取问题当你了解了整本书的全貌，一般而言，你会发现，有些章节你已经熟悉，有些章节你全然不知。这时就要对这些章节进行分析阅读。分析阅读的很多步骤和方法在《如何阅读一本书（How To Read A Book）》有详细的介绍，这里不展开细说。但有时，你在阅读的过程中，会发现阅读的兴趣在下降。信息量愈大，阅读的动力愈弱，最后你就迷失在信息的汪洋之中。我们应该如何避免这样的信息疲劳呢？答案就是去掉冗余的干扰信息。在上一个建议中，我们强调了检视阅读的重要性。那检视阅读的成果是什么呢？那就是你对每个部分（不一定是书中给你划分的章节）所提出的问题，也可以称之为阅读目标。而你要做的就是，找到这些问题的答案，完成自己的阅读目标。这样做过滤了很多作者认为重要，其实和你关心的主旨没有联系的信息，减少了信息疲劳。同时，不同部分之间有关联的问题，可以帮助你更好的串联全书阐述的核心概念，把握整本书的主要脉络。例如，我在阅读《深入理解计算机系统》的异常控制流时，就提出这样的问题：进程是如何管理内存？而部分的答案，在下一个章节虚拟内存中。当我解答这个问题时，我就会将这两个分离的章节的内容，通过一个问题联系在一起，加深了自己的理解。持续重读一本经典优秀的计算机科学书籍，值得你反复的阅读。不要觉得整本书我已经完全理解，就再也不需要重新回顾阅读了。因为此类书籍存在大量信息，而这些信息并没有必要占据我们大脑有限的记忆存储空间。我们要做的就是认真做好第一条建议，当我们需要使用这些书籍解决问题的时候，能第一时间在其中找到我们需要的信息。毫不夸张的说，计算机科学类的书籍生来就是供人反复翻阅的。鉴别烂书作为阅读爱好者，谁能说自己没读过几本烂书呢。在计算机科学这个类别中，烂书的比例一点也不比其他学科低。信息重复（抄袭），结构混乱，论证不清晰（作者对某个技术一知半解）等等，都是烂书的特征。关于烂书，我们要做的就是第一时间将其鉴别出来，然后放到自己的黑名单中。具体如何鉴别烂书，由于本篇幅太长，我可能会新开一篇文章单独讨论。结语以上就是我对于如何阅读计算机科学类书籍的理解。本来想缩短些篇幅，但最后还是决定保留那些我觉得应该详细论述的部分。毕竟这篇文章的初心并非是厕所读物，而是一个阅读爱好者认真地与读者探讨一个严肃的话题。如果可以，我希望在通过我不断地探索，阅读能力的持续提升，我还能在此宝地继续这个话题，完善我的理论。我在下面列出我认为经典优秀的计算机科学书籍，也欢迎大家补充，排名不分先后。 《算法导论》Thomas H.Cormen、 Charles E.Leiserson 《深入理解计算机系统》Randal E. Bryant 《人月神话》Frederick P.Brooks 《编程珠玑》Jon Bentley 《高性能MySQL》施瓦茨 (Baron Schwartz)、 扎伊采夫 (Peter Zaitsev) 《代码大全》Steve McConnell 《程序员修炼之道:从小工到专家》亨特(Andrew Hunt)、 托马斯(David Thomas)" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～这里可以放代码片段噢～//代码片段int main(){ hello world;}" }, { "title": "markdown 语法一览", "url": "/posts/markdown%E8%AF%AD%E6%B3%95%E4%B8%80%E8%A7%88/", "categories": "工具", "tags": "查阅工具", "date": "2022-01-06 21:20:57 +0000", "snippet": "markdown 语法标题语法要创立标题，在段落前加# 共有六个标题等级段落语法使用空白行或多行文本进行分隔换行语法在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行强调语法粗体(bold)：在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）eg: i just love bold text斜体(ltalic):在单词或短语前后添加一个星号（asterisk）或下划线（underscore)eg:Italicized text is the cat’s meow.粗体和斜体：在单词或短语的前后各添加三个星号或下划线eg:This text is really important.引用语法要创建块 ，请在段落前添加一个 &amp;gt; 符号 Dorothy followed her through many of the beautiful rooms in her castle.多个段落的块引用：块引用可以包含多个段落。为段落之间的空白行添加一个 &amp;gt; 符号。 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.嵌套块引用块引用可以嵌套。在要嵌套的段落前添加一个 » 符号带有其它元素的块引用块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan.列表语法有序列表每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 First item Second item Third item Fourth item无序列表在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) first item Second item Third item Fourth item在列表中嵌套其他元素要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符.段落 This is the first list item. Here’s the second list item. I need to add another paragraph below the second list item. And here’s the third list item.引用块 This is the first list item. Here’s the second list item. A blockquote would look great below the second list item. And here’s the third list item.代码块代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。 Open the file. Find the following code block on line 21: &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; Update the title to match the name of your website. 图片 Open the file containing the Linux mascot. Marvel at its beauty. Close the file. 列表 First item Second item Third item Indented item Indented item Fourth item代码语法要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。At the command prompt, type nano.转义反引号如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中.Use `code` in your Markdown file.代码块要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;/head&amp;gt;&amp;lt;/html&amp;gt;Note: 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）.分割线语法要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。Try to put a blank line before……and after a horizontal rule.链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。超链接Markdown语法代码：超链接显示名这是一个链接 Markdown语法。网址和Email地址使用尖括号可以很方便地把URL或者email地址变成可点击的链接。https://markdown.com.cnfake@example.com带格式化的链接强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。I love supporting the EFF.This is the Markdown Guide.See the section on code.图片语法要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。插入图片Markdown语法代码：。链接图片给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。转义字符语法要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。* Without the backslash, this would be a bullet in an unordered list." } ]
